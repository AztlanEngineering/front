{"version":3,"file":"parser.js.js?af134","mappings":"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K,IAAUA,GAAK,IACpBA,GAAK,IAAUA,GAAK,IACpBA,GAAK,IAAUA,GAAK,IACf,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACCA,GAAK,KAAUA,GAAK,KACf,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACM,MAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACM,OAANA,GACM,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,KACf,OAANA,GACM,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACf,OAANA,GACCA,GAAK,MAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACCA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,OACf,QAANA,GACM,QAANA,GACM,QAANA,GACM,QAANA,GACCA,GAAK,OAAUA,GAAK,KAC7B,C","sources":["webpack://@aztlan/template-react/../../node_modules/@formatjs/icu-messageformat-parser/lib/parser.js"],"sourcesContent":["var _a;\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE, } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton, } from '@formatjs/icu-skeleton-parser';\nimport { getBestPattern } from './date-time-pattern-generator';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\".concat(SPACE_SEPARATOR_REGEX.source, \"*\"));\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(\"\".concat(SPACE_SEPARATOR_REGEX.source, \"*$\"));\nfunction createLocation(start, end) {\n    return { start: start, end: end };\n}\n// #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\nvar hasNativeStartsWith = !!String.prototype.startsWith && '_a'.startsWith('a', 1);\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger\n    ? Number.isSafeInteger\n    : function (n) {\n        return (typeof n === 'number' &&\n            isFinite(n) &&\n            Math.floor(n) === n &&\n            Math.abs(n) <= 0x1fffffffffffff);\n    };\n// IE11 does not support y and u.\nvar REGEX_SUPPORTS_U_AND_Y = true;\ntry {\n    var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    /**\n     * legacy Edge or Xbox One browser\n     * Unicode flag support: supported\n     * Pattern_Syntax support: not supported\n     * See https://github.com/formatjs/formatjs/issues/2822\n     */\n    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n}\ncatch (_) {\n    REGEX_SUPPORTS_U_AND_Y = false;\n}\nvar startsWith = hasNativeStartsWith\n    ? // Native\n        function startsWith(s, search, position) {\n            return s.startsWith(search, position);\n        }\n    : // For IE11\n        function startsWith(s, search, position) {\n            return s.slice(position, position + search.length) === search;\n        };\nvar fromCodePoint = hasNativeFromCodePoint\n    ? String.fromCodePoint\n    : // IE11\n        function fromCodePoint() {\n            var codePoints = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                codePoints[_i] = arguments[_i];\n            }\n            var elements = '';\n            var length = codePoints.length;\n            var i = 0;\n            var code;\n            while (length > i) {\n                code = codePoints[i++];\n                if (code > 0x10ffff)\n                    throw RangeError(code + ' is not a valid code point');\n                elements +=\n                    code < 0x10000\n                        ? String.fromCharCode(code)\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\n            }\n            return elements;\n        };\nvar fromEntries = \n// native\nhasNativeFromEntries\n    ? Object.fromEntries\n    : // Ponyfill\n        function fromEntries(entries) {\n            var obj = {};\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                obj[k] = v;\n            }\n            return obj;\n        };\nvar codePointAt = hasNativeCodePointAt\n    ? // Native\n        function codePointAt(s, index) {\n            return s.codePointAt(index);\n        }\n    : // IE 11\n        function codePointAt(s, index) {\n            var size = s.length;\n            if (index < 0 || index >= size) {\n                return undefined;\n            }\n            var first = s.charCodeAt(index);\n            var second;\n            return first < 0xd800 ||\n                first > 0xdbff ||\n                index + 1 === size ||\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\n                second > 0xdfff\n                ? first\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\n        };\nvar trimStart = hasTrimStart\n    ? // Native\n        function trimStart(s) {\n            return s.trimStart();\n        }\n    : // Ponyfill\n        function trimStart(s) {\n            return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n        };\nvar trimEnd = hasTrimEnd\n    ? // Native\n        function trimEnd(s) {\n            return s.trimEnd();\n        }\n    : // Ponyfill\n        function trimEnd(s) {\n            return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n        };\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\nfunction RE(s, flag) {\n    return new RegExp(s, flag);\n}\n// #endregion\nvar matchIdentifierAtIndex;\nif (REGEX_SUPPORTS_U_AND_Y) {\n    // Native\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var _a;\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n    };\n}\nelse {\n    // IE11\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var match = [];\n        while (true) {\n            var c = codePointAt(s, index);\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n                break;\n            }\n            match.push(c);\n            index += c >= 0x10000 ? 2 : 1;\n        }\n        return fromCodePoint.apply(void 0, match);\n    };\n}\nvar Parser = /** @class */ (function () {\n    function Parser(message, options) {\n        if (options === void 0) { options = {}; }\n        this.message = message;\n        this.position = { offset: 0, line: 1, column: 1 };\n        this.ignoreTag = !!options.ignoreTag;\n        this.locale = options.locale;\n        this.requiresOtherClause = !!options.requiresOtherClause;\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n    }\n    Parser.prototype.parse = function () {\n        if (this.offset() !== 0) {\n            throw Error('parser can only be used once');\n        }\n        return this.parseMessage(0, '', false);\n    };\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n        var elements = [];\n        while (!this.isEOF()) {\n            var char = this.char();\n            if (char === 123 /* `{` */) {\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\n                break;\n            }\n            else if (char === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n                var position = this.clonePosition();\n                this.bump();\n                elements.push({\n                    type: TYPE.pound,\n                    location: createLocation(position, this.clonePosition()),\n                });\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                this.peek() === 47 // char code for '/'\n            ) {\n                if (expectingCloseTag) {\n                    break;\n                }\n                else {\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n                }\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                _isAlpha(this.peek() || 0)) {\n                var result = this.parseTag(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else {\n                var result = this.parseLiteral(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n        }\n        return { val: elements, err: null };\n    };\n    /**\n     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n     * are accepted:\n     *\n     * ```\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n     * tagName ::= [a-z] (PENChar)*\n     * PENChar ::=\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n     * ```\n     *\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\n     * since other tag-based engines like React allow it\n     */\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n        var startPosition = this.clonePosition();\n        this.bump(); // `<`\n        var tagName = this.parseTagName();\n        this.bumpSpace();\n        if (this.bumpIf('/>')) {\n            // Self closing tag\n            return {\n                val: {\n                    type: TYPE.literal,\n                    value: \"<\".concat(tagName, \"/>\"),\n                    location: createLocation(startPosition, this.clonePosition()),\n                },\n                err: null,\n            };\n        }\n        else if (this.bumpIf('>')) {\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n            if (childrenResult.err) {\n                return childrenResult;\n            }\n            var children = childrenResult.val;\n            // Expecting a close tag\n            var endTagStartPosition = this.clonePosition();\n            if (this.bumpIf('</')) {\n                if (this.isEOF() || !_isAlpha(this.char())) {\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                var closingTagNameStartPosition = this.clonePosition();\n                var closingTagName = this.parseTagName();\n                if (tagName !== closingTagName) {\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n                }\n                this.bumpSpace();\n                if (!this.bumpIf('>')) {\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                return {\n                    val: {\n                        type: TYPE.tag,\n                        value: tagName,\n                        children: children,\n                        location: createLocation(startPosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            else {\n                return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n            }\n        }\n        else {\n            return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n        }\n    };\n    /**\n     * This method assumes that the caller has peeked ahead for the first tag character.\n     */\n    Parser.prototype.parseTagName = function () {\n        var startOffset = this.offset();\n        this.bump(); // the first tag name character\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n            this.bump();\n        }\n        return this.message.slice(startOffset, this.offset());\n    };\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n        var start = this.clonePosition();\n        var value = '';\n        while (true) {\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\n            if (parseQuoteResult) {\n                value += parseQuoteResult;\n                continue;\n            }\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n            if (parseUnquotedResult) {\n                value += parseUnquotedResult;\n                continue;\n            }\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n            if (parseLeftAngleResult) {\n                value += parseLeftAngleResult;\n                continue;\n            }\n            break;\n        }\n        var location = createLocation(start, this.clonePosition());\n        return {\n            val: { type: TYPE.literal, value: value, location: location },\n            err: null,\n        };\n    };\n    Parser.prototype.tryParseLeftAngleBracket = function () {\n        if (!this.isEOF() &&\n            this.char() === 60 /* `<` */ &&\n            (this.ignoreTag ||\n                // If at the opening tag or closing tag position, bail.\n                !_isAlphaOrSlash(this.peek() || 0))) {\n            this.bump(); // `<`\n            return '<';\n        }\n        return null;\n    };\n    /**\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n     */\n    Parser.prototype.tryParseQuote = function (parentArgType) {\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\n            return null;\n        }\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n        // Check if is valid escaped character\n        switch (this.peek()) {\n            case 39 /* `'` */:\n                // double quote, should return as a single quote.\n                this.bump();\n                this.bump();\n                return \"'\";\n            // '{', '<', '>', '}'\n            case 123:\n            case 60:\n            case 62:\n            case 125:\n                break;\n            case 35: // '#'\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n                    break;\n                }\n                return null;\n            default:\n                return null;\n        }\n        this.bump(); // apostrophe\n        var codePoints = [this.char()]; // escaped char\n        this.bump();\n        // read chars until the optional closing apostrophe is found\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch === 39 /* `'` */) {\n                if (this.peek() === 39 /* `'` */) {\n                    codePoints.push(39);\n                    // Bump one more time because we need to skip 2 characters.\n                    this.bump();\n                }\n                else {\n                    // Optional closing apostrophe.\n                    this.bump();\n                    break;\n                }\n            }\n            else {\n                codePoints.push(ch);\n            }\n            this.bump();\n        }\n        return fromCodePoint.apply(void 0, codePoints);\n    };\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n        if (this.isEOF()) {\n            return null;\n        }\n        var ch = this.char();\n        if (ch === 60 /* `<` */ ||\n            ch === 123 /* `{` */ ||\n            (ch === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\n            return null;\n        }\n        else {\n            this.bump();\n            return fromCodePoint(ch);\n        }\n    };\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n        var openingBracePosition = this.clonePosition();\n        this.bump(); // `{`\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        if (this.char() === 125 /* `}` */) {\n            this.bump();\n            return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        // argument name\n        var value = this.parseIdentifierIfPossible().value;\n        if (!value) {\n            return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        switch (this.char()) {\n            // Simple argument: `{name}`\n            case 125 /* `}` */: {\n                this.bump(); // `}`\n                return {\n                    val: {\n                        type: TYPE.argument,\n                        // value does not include the opening and closing braces.\n                        value: value,\n                        location: createLocation(openingBracePosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            // Argument with options: `{name, format, ...}`\n            case 44 /* `,` */: {\n                this.bump(); // `,`\n                this.bumpSpace();\n                if (this.isEOF()) {\n                    return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n                }\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n            }\n            default:\n                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n    };\n    /**\n     * Advance the parser until the end of the identifier, if it is currently on\n     * an identifier character. Return an empty string otherwise.\n     */\n    Parser.prototype.parseIdentifierIfPossible = function () {\n        var startingPosition = this.clonePosition();\n        var startOffset = this.offset();\n        var value = matchIdentifierAtIndex(this.message, startOffset);\n        var endOffset = startOffset + value.length;\n        this.bumpTo(endOffset);\n        var endPosition = this.clonePosition();\n        var location = createLocation(startingPosition, endPosition);\n        return { value: value, location: location };\n    };\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n        var _a;\n        // Parse this range:\n        // {name, type, style}\n        //        ^---^\n        var typeStartPosition = this.clonePosition();\n        var argType = this.parseIdentifierIfPossible().value;\n        var typeEndPosition = this.clonePosition();\n        switch (argType) {\n            case '':\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\n                return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n            case 'number':\n            case 'date':\n            case 'time': {\n                // Parse this range:\n                // {name, number, style}\n                //              ^-------^\n                this.bumpSpace();\n                var styleAndLocation = null;\n                if (this.bumpIf(',')) {\n                    this.bumpSpace();\n                    var styleStartPosition = this.clonePosition();\n                    var result = this.parseSimpleArgStyleIfPossible();\n                    if (result.err) {\n                        return result;\n                    }\n                    var style = trimEnd(result.val);\n                    if (style.length === 0) {\n                        return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\n                // Extract style or skeleton\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n                    // Skeleton starts with `::`.\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\n                    if (argType === 'number') {\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n                        if (result.err) {\n                            return result;\n                        }\n                        return {\n                            val: { type: TYPE.number, value: value, location: location_1, style: result.val },\n                            err: null,\n                        };\n                    }\n                    else {\n                        if (skeleton.length === 0) {\n                            return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n                        }\n                        var dateTimePattern = skeleton;\n                        // Get \"best match\" pattern only if locale is passed, if not, let it\n                        // pass as-is where `parseDateTimeSkeleton()` will throw an error\n                        // for unsupported patterns.\n                        if (this.locale) {\n                            dateTimePattern = getBestPattern(skeleton, this.locale);\n                        }\n                        var style = {\n                            type: SKELETON_TYPE.dateTime,\n                            pattern: dateTimePattern,\n                            location: styleAndLocation.styleLocation,\n                            parsedOptions: this.shouldParseSkeletons\n                                ? parseDateTimeSkeleton(dateTimePattern)\n                                : {},\n                        };\n                        var type = argType === 'date' ? TYPE.date : TYPE.time;\n                        return {\n                            val: { type: type, value: value, location: location_1, style: style },\n                            err: null,\n                        };\n                    }\n                }\n                // Regular style or no style.\n                return {\n                    val: {\n                        type: argType === 'number'\n                            ? TYPE.number\n                            : argType === 'date'\n                                ? TYPE.date\n                                : TYPE.time,\n                        value: value,\n                        location: location_1,\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\n                    },\n                    err: null,\n                };\n            }\n            case 'plural':\n            case 'selectordinal':\n            case 'select': {\n                // Parse this range:\n                // {name, plural, options}\n                //              ^---------^\n                var typeEndPosition_1 = this.clonePosition();\n                this.bumpSpace();\n                if (!this.bumpIf(',')) {\n                    return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n                }\n                this.bumpSpace();\n                // Parse offset:\n                // {name, plural, offset:1, options}\n                //                ^-----^\n                //\n                // or the first option:\n                //\n                // {name, plural, one {...} other {...}}\n                //                ^--^\n                var identifierAndLocation = this.parseIdentifierIfPossible();\n                var pluralOffset = 0;\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n                    if (!this.bumpIf(':')) {\n                        return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    this.bumpSpace();\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n                    if (result.err) {\n                        return result;\n                    }\n                    // Parse another identifier for option parsing\n                    this.bumpSpace();\n                    identifierAndLocation = this.parseIdentifierIfPossible();\n                    pluralOffset = result.val;\n                }\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n                if (optionsResult.err) {\n                    return optionsResult;\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\n                if (argType === 'select') {\n                    return {\n                        val: {\n                            type: TYPE.select,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n                else {\n                    return {\n                        val: {\n                            type: TYPE.plural,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            offset: pluralOffset,\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n            }\n            default:\n                return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n        }\n    };\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n        // Parse: {value, number, ::currency/GBP }\n        //\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bump(); // `}`\n        return { val: true, err: null };\n    };\n    /**\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n     */\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n        var nestedBraces = 0;\n        var startPosition = this.clonePosition();\n        while (!this.isEOF()) {\n            var ch = this.char();\n            switch (ch) {\n                case 39 /* `'` */: {\n                    // Treat apostrophe as quoting but include it in the style part.\n                    // Find the end of the quoted literal text.\n                    this.bump();\n                    var apostrophePosition = this.clonePosition();\n                    if (!this.bumpUntil(\"'\")) {\n                        return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n                    }\n                    this.bump();\n                    break;\n                }\n                case 123 /* `{` */: {\n                    nestedBraces += 1;\n                    this.bump();\n                    break;\n                }\n                case 125 /* `}` */: {\n                    if (nestedBraces > 0) {\n                        nestedBraces -= 1;\n                    }\n                    else {\n                        return {\n                            val: this.message.slice(startPosition.offset, this.offset()),\n                            err: null,\n                        };\n                    }\n                    break;\n                }\n                default:\n                    this.bump();\n                    break;\n            }\n        }\n        return {\n            val: this.message.slice(startPosition.offset, this.offset()),\n            err: null,\n        };\n    };\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n        var tokens = [];\n        try {\n            tokens = parseNumberSkeletonFromString(skeleton);\n        }\n        catch (e) {\n            return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n        }\n        return {\n            val: {\n                type: SKELETON_TYPE.number,\n                tokens: tokens,\n                location: location,\n                parsedOptions: this.shouldParseSkeletons\n                    ? parseNumberSkeleton(tokens)\n                    : {},\n            },\n            err: null,\n        };\n    };\n    /**\n     * @param nesting_level The current nesting level of messages.\n     *     This can be positive when parsing message fragment in select or plural argument options.\n     * @param parent_arg_type The parent argument's type.\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n     *     the argument. It is a by-product of a previous parsing attempt.\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\n     *     the closing tag boundary.\n     */\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n        var _a;\n        var hasOtherClause = false;\n        var options = [];\n        var parsedSelectors = new Set();\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\n        // Parse:\n        // one {one apple}\n        // ^--^\n        while (true) {\n            if (selector.length === 0) {\n                var startPosition = this.clonePosition();\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\n                    // Try parse `={number}` selector\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n                    if (result.err) {\n                        return result;\n                    }\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\n                    selector = this.message.slice(startPosition.offset, this.offset());\n                }\n                else {\n                    break;\n                }\n            }\n            // Duplicate selector clauses\n            if (parsedSelectors.has(selector)) {\n                return this.error(parentArgType === 'select'\n                    ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\n                    : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n            }\n            if (selector === 'other') {\n                hasOtherClause = true;\n            }\n            // Parse:\n            // one {one apple}\n            //     ^----------^\n            this.bumpSpace();\n            var openingBracePosition = this.clonePosition();\n            if (!this.bumpIf('{')) {\n                return this.error(parentArgType === 'select'\n                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\n                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n            if (fragmentResult.err) {\n                return fragmentResult;\n            }\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n            if (argCloseResult.err) {\n                return argCloseResult;\n            }\n            options.push([\n                selector,\n                {\n                    value: fragmentResult.val,\n                    location: createLocation(openingBracePosition, this.clonePosition()),\n                },\n            ]);\n            // Keep track of the existing selectors\n            parsedSelectors.add(selector);\n            // Prep next selector clause.\n            this.bumpSpace();\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\n        }\n        if (options.length === 0) {\n            return this.error(parentArgType === 'select'\n                ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\n                : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        if (this.requiresOtherClause && !hasOtherClause) {\n            return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        return { val: options, err: null };\n    };\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n        var sign = 1;\n        var startingPosition = this.clonePosition();\n        if (this.bumpIf('+')) {\n        }\n        else if (this.bumpIf('-')) {\n            sign = -1;\n        }\n        var hasDigits = false;\n        var decimal = 0;\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\n                hasDigits = true;\n                decimal = decimal * 10 + (ch - 48);\n                this.bump();\n            }\n            else {\n                break;\n            }\n        }\n        var location = createLocation(startingPosition, this.clonePosition());\n        if (!hasDigits) {\n            return this.error(expectNumberError, location);\n        }\n        decimal *= sign;\n        if (!isSafeInteger(decimal)) {\n            return this.error(invalidNumberError, location);\n        }\n        return { val: decimal, err: null };\n    };\n    Parser.prototype.offset = function () {\n        return this.position.offset;\n    };\n    Parser.prototype.isEOF = function () {\n        return this.offset() === this.message.length;\n    };\n    Parser.prototype.clonePosition = function () {\n        // This is much faster than `Object.assign` or spread.\n        return {\n            offset: this.position.offset,\n            line: this.position.line,\n            column: this.position.column,\n        };\n    };\n    /**\n     * Return the code point at the current position of the parser.\n     * Throws if the index is out of bound.\n     */\n    Parser.prototype.char = function () {\n        var offset = this.position.offset;\n        if (offset >= this.message.length) {\n            throw Error('out of bound');\n        }\n        var code = codePointAt(this.message, offset);\n        if (code === undefined) {\n            throw Error(\"Offset \".concat(offset, \" is at invalid UTF-16 code unit boundary\"));\n        }\n        return code;\n    };\n    Parser.prototype.error = function (kind, location) {\n        return {\n            val: null,\n            err: {\n                kind: kind,\n                message: this.message,\n                location: location,\n            },\n        };\n    };\n    /** Bump the parser to the next UTF-16 code unit. */\n    Parser.prototype.bump = function () {\n        if (this.isEOF()) {\n            return;\n        }\n        var code = this.char();\n        if (code === 10 /* '\\n' */) {\n            this.position.line += 1;\n            this.position.column = 1;\n            this.position.offset += 1;\n        }\n        else {\n            this.position.column += 1;\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n            this.position.offset += code < 0x10000 ? 1 : 2;\n        }\n    };\n    /**\n     * If the substring starting at the current position of the parser has\n     * the given prefix, then bump the parser to the character immediately\n     * following the prefix and return true. Otherwise, don't bump the parser\n     * and return false.\n     */\n    Parser.prototype.bumpIf = function (prefix) {\n        if (startsWith(this.message, prefix, this.offset())) {\n            for (var i = 0; i < prefix.length; i++) {\n                this.bump();\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Bump the parser until the pattern character is found and return `true`.\n     * Otherwise bump to the end of the file and return `false`.\n     */\n    Parser.prototype.bumpUntil = function (pattern) {\n        var currentOffset = this.offset();\n        var index = this.message.indexOf(pattern, currentOffset);\n        if (index >= 0) {\n            this.bumpTo(index);\n            return true;\n        }\n        else {\n            this.bumpTo(this.message.length);\n            return false;\n        }\n    };\n    /**\n     * Bump the parser to the target offset.\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\n     */\n    Parser.prototype.bumpTo = function (targetOffset) {\n        if (this.offset() > targetOffset) {\n            throw Error(\"targetOffset \".concat(targetOffset, \" must be greater than or equal to the current offset \").concat(this.offset()));\n        }\n        targetOffset = Math.min(targetOffset, this.message.length);\n        while (true) {\n            var offset = this.offset();\n            if (offset === targetOffset) {\n                break;\n            }\n            if (offset > targetOffset) {\n                throw Error(\"targetOffset \".concat(targetOffset, \" is at invalid UTF-16 code unit boundary\"));\n            }\n            this.bump();\n            if (this.isEOF()) {\n                break;\n            }\n        }\n    };\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\n    Parser.prototype.bumpSpace = function () {\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\n            this.bump();\n        }\n    };\n    /**\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n     * If the input has been exhausted, then this returns null.\n     */\n    Parser.prototype.peek = function () {\n        if (this.isEOF()) {\n            return null;\n        }\n        var code = this.char();\n        var offset = this.offset();\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n    };\n    return Parser;\n}());\nexport { Parser };\n/**\n * This check if codepoint is alphabet (lower & uppercase)\n * @param codepoint\n * @returns\n */\nfunction _isAlpha(codepoint) {\n    return ((codepoint >= 97 && codepoint <= 122) ||\n        (codepoint >= 65 && codepoint <= 90));\n}\nfunction _isAlphaOrSlash(codepoint) {\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\n}\n/** See `parseTag` function docs. */\nfunction _isPotentialElementNameChar(c) {\n    return (c === 45 /* '-' */ ||\n        c === 46 /* '.' */ ||\n        (c >= 48 && c <= 57) /* 0..9 */ ||\n        c === 95 /* '_' */ ||\n        (c >= 97 && c <= 122) /** a..z */ ||\n        (c >= 65 && c <= 90) /* A..Z */ ||\n        c == 0xb7 ||\n        (c >= 0xc0 && c <= 0xd6) ||\n        (c >= 0xd8 && c <= 0xf6) ||\n        (c >= 0xf8 && c <= 0x37d) ||\n        (c >= 0x37f && c <= 0x1fff) ||\n        (c >= 0x200c && c <= 0x200d) ||\n        (c >= 0x203f && c <= 0x2040) ||\n        (c >= 0x2070 && c <= 0x218f) ||\n        (c >= 0x2c00 && c <= 0x2fef) ||\n        (c >= 0x3001 && c <= 0xd7ff) ||\n        (c >= 0xf900 && c <= 0xfdcf) ||\n        (c >= 0xfdf0 && c <= 0xfffd) ||\n        (c >= 0x10000 && c <= 0xeffff));\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isWhiteSpace(c) {\n    return ((c >= 0x0009 && c <= 0x000d) ||\n        c === 0x0020 ||\n        c === 0x0085 ||\n        (c >= 0x200e && c <= 0x200f) ||\n        c === 0x2028 ||\n        c === 0x2029);\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isPatternSyntax(c) {\n    return ((c >= 0x0021 && c <= 0x0023) ||\n        c === 0x0024 ||\n        (c >= 0x0025 && c <= 0x0027) ||\n        c === 0x0028 ||\n        c === 0x0029 ||\n        c === 0x002a ||\n        c === 0x002b ||\n        c === 0x002c ||\n        c === 0x002d ||\n        (c >= 0x002e && c <= 0x002f) ||\n        (c >= 0x003a && c <= 0x003b) ||\n        (c >= 0x003c && c <= 0x003e) ||\n        (c >= 0x003f && c <= 0x0040) ||\n        c === 0x005b ||\n        c === 0x005c ||\n        c === 0x005d ||\n        c === 0x005e ||\n        c === 0x0060 ||\n        c === 0x007b ||\n        c === 0x007c ||\n        c === 0x007d ||\n        c === 0x007e ||\n        c === 0x00a1 ||\n        (c >= 0x00a2 && c <= 0x00a5) ||\n        c === 0x00a6 ||\n        c === 0x00a7 ||\n        c === 0x00a9 ||\n        c === 0x00ab ||\n        c === 0x00ac ||\n        c === 0x00ae ||\n        c === 0x00b0 ||\n        c === 0x00b1 ||\n        c === 0x00b6 ||\n        c === 0x00bb ||\n        c === 0x00bf ||\n        c === 0x00d7 ||\n        c === 0x00f7 ||\n        (c >= 0x2010 && c <= 0x2015) ||\n        (c >= 0x2016 && c <= 0x2017) ||\n        c === 0x2018 ||\n        c === 0x2019 ||\n        c === 0x201a ||\n        (c >= 0x201b && c <= 0x201c) ||\n        c === 0x201d ||\n        c === 0x201e ||\n        c === 0x201f ||\n        (c >= 0x2020 && c <= 0x2027) ||\n        (c >= 0x2030 && c <= 0x2038) ||\n        c === 0x2039 ||\n        c === 0x203a ||\n        (c >= 0x203b && c <= 0x203e) ||\n        (c >= 0x2041 && c <= 0x2043) ||\n        c === 0x2044 ||\n        c === 0x2045 ||\n        c === 0x2046 ||\n        (c >= 0x2047 && c <= 0x2051) ||\n        c === 0x2052 ||\n        c === 0x2053 ||\n        (c >= 0x2055 && c <= 0x205e) ||\n        (c >= 0x2190 && c <= 0x2194) ||\n        (c >= 0x2195 && c <= 0x2199) ||\n        (c >= 0x219a && c <= 0x219b) ||\n        (c >= 0x219c && c <= 0x219f) ||\n        c === 0x21a0 ||\n        (c >= 0x21a1 && c <= 0x21a2) ||\n        c === 0x21a3 ||\n        (c >= 0x21a4 && c <= 0x21a5) ||\n        c === 0x21a6 ||\n        (c >= 0x21a7 && c <= 0x21ad) ||\n        c === 0x21ae ||\n        (c >= 0x21af && c <= 0x21cd) ||\n        (c >= 0x21ce && c <= 0x21cf) ||\n        (c >= 0x21d0 && c <= 0x21d1) ||\n        c === 0x21d2 ||\n        c === 0x21d3 ||\n        c === 0x21d4 ||\n        (c >= 0x21d5 && c <= 0x21f3) ||\n        (c >= 0x21f4 && c <= 0x22ff) ||\n        (c >= 0x2300 && c <= 0x2307) ||\n        c === 0x2308 ||\n        c === 0x2309 ||\n        c === 0x230a ||\n        c === 0x230b ||\n        (c >= 0x230c && c <= 0x231f) ||\n        (c >= 0x2320 && c <= 0x2321) ||\n        (c >= 0x2322 && c <= 0x2328) ||\n        c === 0x2329 ||\n        c === 0x232a ||\n        (c >= 0x232b && c <= 0x237b) ||\n        c === 0x237c ||\n        (c >= 0x237d && c <= 0x239a) ||\n        (c >= 0x239b && c <= 0x23b3) ||\n        (c >= 0x23b4 && c <= 0x23db) ||\n        (c >= 0x23dc && c <= 0x23e1) ||\n        (c >= 0x23e2 && c <= 0x2426) ||\n        (c >= 0x2427 && c <= 0x243f) ||\n        (c >= 0x2440 && c <= 0x244a) ||\n        (c >= 0x244b && c <= 0x245f) ||\n        (c >= 0x2500 && c <= 0x25b6) ||\n        c === 0x25b7 ||\n        (c >= 0x25b8 && c <= 0x25c0) ||\n        c === 0x25c1 ||\n        (c >= 0x25c2 && c <= 0x25f7) ||\n        (c >= 0x25f8 && c <= 0x25ff) ||\n        (c >= 0x2600 && c <= 0x266e) ||\n        c === 0x266f ||\n        (c >= 0x2670 && c <= 0x2767) ||\n        c === 0x2768 ||\n        c === 0x2769 ||\n        c === 0x276a ||\n        c === 0x276b ||\n        c === 0x276c ||\n        c === 0x276d ||\n        c === 0x276e ||\n        c === 0x276f ||\n        c === 0x2770 ||\n        c === 0x2771 ||\n        c === 0x2772 ||\n        c === 0x2773 ||\n        c === 0x2774 ||\n        c === 0x2775 ||\n        (c >= 0x2794 && c <= 0x27bf) ||\n        (c >= 0x27c0 && c <= 0x27c4) ||\n        c === 0x27c5 ||\n        c === 0x27c6 ||\n        (c >= 0x27c7 && c <= 0x27e5) ||\n        c === 0x27e6 ||\n        c === 0x27e7 ||\n        c === 0x27e8 ||\n        c === 0x27e9 ||\n        c === 0x27ea ||\n        c === 0x27eb ||\n        c === 0x27ec ||\n        c === 0x27ed ||\n        c === 0x27ee ||\n        c === 0x27ef ||\n        (c >= 0x27f0 && c <= 0x27ff) ||\n        (c >= 0x2800 && c <= 0x28ff) ||\n        (c >= 0x2900 && c <= 0x2982) ||\n        c === 0x2983 ||\n        c === 0x2984 ||\n        c === 0x2985 ||\n        c === 0x2986 ||\n        c === 0x2987 ||\n        c === 0x2988 ||\n        c === 0x2989 ||\n        c === 0x298a ||\n        c === 0x298b ||\n        c === 0x298c ||\n        c === 0x298d ||\n        c === 0x298e ||\n        c === 0x298f ||\n        c === 0x2990 ||\n        c === 0x2991 ||\n        c === 0x2992 ||\n        c === 0x2993 ||\n        c === 0x2994 ||\n        c === 0x2995 ||\n        c === 0x2996 ||\n        c === 0x2997 ||\n        c === 0x2998 ||\n        (c >= 0x2999 && c <= 0x29d7) ||\n        c === 0x29d8 ||\n        c === 0x29d9 ||\n        c === 0x29da ||\n        c === 0x29db ||\n        (c >= 0x29dc && c <= 0x29fb) ||\n        c === 0x29fc ||\n        c === 0x29fd ||\n        (c >= 0x29fe && c <= 0x2aff) ||\n        (c >= 0x2b00 && c <= 0x2b2f) ||\n        (c >= 0x2b30 && c <= 0x2b44) ||\n        (c >= 0x2b45 && c <= 0x2b46) ||\n        (c >= 0x2b47 && c <= 0x2b4c) ||\n        (c >= 0x2b4d && c <= 0x2b73) ||\n        (c >= 0x2b74 && c <= 0x2b75) ||\n        (c >= 0x2b76 && c <= 0x2b95) ||\n        c === 0x2b96 ||\n        (c >= 0x2b97 && c <= 0x2bff) ||\n        (c >= 0x2e00 && c <= 0x2e01) ||\n        c === 0x2e02 ||\n        c === 0x2e03 ||\n        c === 0x2e04 ||\n        c === 0x2e05 ||\n        (c >= 0x2e06 && c <= 0x2e08) ||\n        c === 0x2e09 ||\n        c === 0x2e0a ||\n        c === 0x2e0b ||\n        c === 0x2e0c ||\n        c === 0x2e0d ||\n        (c >= 0x2e0e && c <= 0x2e16) ||\n        c === 0x2e17 ||\n        (c >= 0x2e18 && c <= 0x2e19) ||\n        c === 0x2e1a ||\n        c === 0x2e1b ||\n        c === 0x2e1c ||\n        c === 0x2e1d ||\n        (c >= 0x2e1e && c <= 0x2e1f) ||\n        c === 0x2e20 ||\n        c === 0x2e21 ||\n        c === 0x2e22 ||\n        c === 0x2e23 ||\n        c === 0x2e24 ||\n        c === 0x2e25 ||\n        c === 0x2e26 ||\n        c === 0x2e27 ||\n        c === 0x2e28 ||\n        c === 0x2e29 ||\n        (c >= 0x2e2a && c <= 0x2e2e) ||\n        c === 0x2e2f ||\n        (c >= 0x2e30 && c <= 0x2e39) ||\n        (c >= 0x2e3a && c <= 0x2e3b) ||\n        (c >= 0x2e3c && c <= 0x2e3f) ||\n        c === 0x2e40 ||\n        c === 0x2e41 ||\n        c === 0x2e42 ||\n        (c >= 0x2e43 && c <= 0x2e4f) ||\n        (c >= 0x2e50 && c <= 0x2e51) ||\n        c === 0x2e52 ||\n        (c >= 0x2e53 && c <= 0x2e7f) ||\n        (c >= 0x3001 && c <= 0x3003) ||\n        c === 0x3008 ||\n        c === 0x3009 ||\n        c === 0x300a ||\n        c === 0x300b ||\n        c === 0x300c ||\n        c === 0x300d ||\n        c === 0x300e ||\n        c === 0x300f ||\n        c === 0x3010 ||\n        c === 0x3011 ||\n        (c >= 0x3012 && c <= 0x3013) ||\n        c === 0x3014 ||\n        c === 0x3015 ||\n        c === 0x3016 ||\n        c === 0x3017 ||\n        c === 0x3018 ||\n        c === 0x3019 ||\n        c === 0x301a ||\n        c === 0x301b ||\n        c === 0x301c ||\n        c === 0x301d ||\n        (c >= 0x301e && c <= 0x301f) ||\n        c === 0x3020 ||\n        c === 0x3030 ||\n        c === 0xfd3e ||\n        c === 0xfd3f ||\n        (c >= 0xfe45 && c <= 0xfe46));\n}\n"],"names":["_a","SPACE_SEPARATOR_START_REGEX","RegExp","concat","SPACE_SEPARATOR_REGEX","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","Object","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","isSafeInteger","Number","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","RE","exec","_","matchIdentifierAtIndex","s","search","position","slice","length","codePoints","_i","arguments","code","elements","i","RangeError","fromCharCode","entries","obj","entries_1","k","v","index","size","second","first","charCodeAt","replace","flag","IDENTIFIER_PREFIX_RE_1","lastIndex","match","c","undefined","_isWhiteSpace","_isPatternSyntax","push","apply","Parser","message","options","this","offset","line","column","ignoreTag","locale","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","peek","error","ErrorKind","UNMATCHED_CLOSING_TAG","clonePosition","_isAlpha","parseTag","parseLiteral","bump","type","TYPE","pound","location","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","value","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","tag","UNCLOSED_TAG","startOffset","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","codepoint","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","parseNumberSkeletonFromString","number","EXPECT_DATE_TIME_SKELETON","dateTimePattern","getBestPattern","SKELETON_TYPE","dateTime","pattern","parsedOptions","parseDateTimeSkeleton","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","__assign","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","parseNumberSkeleton","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode"],"sourceRoot":""}