{"version":3,"file":"react-router.js.js?8a930","mappings":"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","sources":["webpack://@aztlan/template-react/../modules/miniCreateReactContext.js","webpack://@aztlan/template-react/../modules/createContext.js","webpack://@aztlan/template-react/../modules/createNamedContext.js","webpack://@aztlan/template-react/../modules/HistoryContext.js","webpack://@aztlan/template-react/../modules/RouterContext.js","webpack://@aztlan/template-react/../modules/Router.js","webpack://@aztlan/template-react/../modules/MemoryRouter.js","webpack://@aztlan/template-react/../modules/Lifecycle.js","webpack://@aztlan/template-react/../modules/matchPath.js","webpack://@aztlan/template-react/../modules/Route.js","webpack://@aztlan/template-react/../modules/StaticRouter.js","webpack://@aztlan/template-react/../modules/Switch.js","webpack://@aztlan/template-react/../modules/hooks.js"],"sourcesContent":["// MIT License\n// Copyright (c) 2019-present StringEpsilon <StringEpsilon@gmail.com>\n// Copyright (c) 2017-2019 James Kyle <me@thejameskyle.com>\n// https://github.com/StringEpsilon/mini-create-react-context\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"tiny-warning\";\n\nconst MAX_SIGNED_31_BIT_INT = 1073741823;\n\nconst commonjsGlobal =\n  typeof globalThis !== \"undefined\" // 'global proper'\n    ? // eslint-disable-next-line no-undef\n      globalThis\n    : typeof window !== \"undefined\"\n    ? window // Browser\n    : typeof global !== \"undefined\"\n    ? global // node.js\n    : {};\n\nfunction getUniqueId() {\n  let key = \"__global_unique_id__\";\n  return (commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1);\n}\n\n// Inlined Object.is polyfill.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nfunction objectIs(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // eslint-disable-next-line no-self-compare\n    return x !== x && y !== y;\n  }\n}\n\nfunction createEventEmitter(value) {\n  let handlers = [];\n  return {\n    on(handler) {\n      handlers.push(handler);\n    },\n\n    off(handler) {\n      handlers = handlers.filter(h => h !== handler);\n    },\n\n    get() {\n      return value;\n    },\n\n    set(newValue, changedBits) {\n      value = newValue;\n      handlers.forEach(handler => handler(value, changedBits));\n    }\n  };\n}\n\nfunction onlyChild(children) {\n  return Array.isArray(children) ? children[0] : children;\n}\n\nexport default function createReactContext(defaultValue, calculateChangedBits) {\n  const contextProp = \"__create-react-context-\" + getUniqueId() + \"__\";\n\n  class Provider extends React.Component {\n    emitter = createEventEmitter(this.props.value);\n\n    static childContextTypes = {\n      [contextProp]: PropTypes.object.isRequired\n    };\n\n    getChildContext() {\n      return {\n        [contextProp]: this.emitter\n      };\n    }\n\n    componentWillReceiveProps(nextProps) {\n      if (this.props.value !== nextProps.value) {\n        let oldValue = this.props.value;\n        let newValue = nextProps.value;\n        let changedBits;\n\n        if (objectIs(oldValue, newValue)) {\n          changedBits = 0; // No change\n        } else {\n          changedBits =\n            typeof calculateChangedBits === \"function\"\n              ? calculateChangedBits(oldValue, newValue)\n              : MAX_SIGNED_31_BIT_INT;\n          if (process.env.NODE_ENV !== \"production\") {\n            warning(\n              (changedBits & MAX_SIGNED_31_BIT_INT) === changedBits,\n              \"calculateChangedBits: Expected the return value to be a \" +\n                \"31-bit integer. Instead received: \" +\n                changedBits\n            );\n          }\n\n          changedBits |= 0;\n\n          if (changedBits !== 0) {\n            this.emitter.set(nextProps.value, changedBits);\n          }\n        }\n      }\n    }\n\n    render() {\n      return this.props.children;\n    }\n  }\n\n  class Consumer extends React.Component {\n    static contextTypes = {\n      [contextProp]: PropTypes.object\n    };\n\n    observedBits;\n\n    state = {\n      value: this.getValue()\n    };\n\n    componentWillReceiveProps(nextProps) {\n      let { observedBits } = nextProps;\n      this.observedBits =\n        observedBits === undefined || observedBits === null\n          ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default\n          : observedBits;\n    }\n\n    componentDidMount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].on(this.onUpdate);\n      }\n      let { observedBits } = this.props;\n      this.observedBits =\n        observedBits === undefined || observedBits === null\n          ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default\n          : observedBits;\n    }\n\n    componentWillUnmount() {\n      if (this.context[contextProp]) {\n        this.context[contextProp].off(this.onUpdate);\n      }\n    }\n\n    getValue() {\n      if (this.context[contextProp]) {\n        return this.context[contextProp].get();\n      } else {\n        return defaultValue;\n      }\n    }\n\n    onUpdate = (newValue, changedBits) => {\n      const observedBits = this.observedBits | 0;\n      if ((observedBits & changedBits) !== 0) {\n        this.setState({ value: this.getValue() });\n      }\n    };\n\n    render() {\n      return onlyChild(this.props.children)(this.state.value);\n    }\n  }\n\n  return {\n    Provider,\n    Consumer\n  };\n}\n","// MIT License\n// Copyright (c) 2019-present StringEpsilon <StringEpsilon@gmail.com>\n// Copyright (c) 2017-2019 James Kyle <me@thejameskyle.com>\n// https://github.com/StringEpsilon/mini-create-react-context\nimport React from \"react\";\nimport createReactContext from \"./miniCreateReactContext\";\n\nexport default React.createContext || createReactContext;\n","// TODO: Replace with React.createContext once we can assume React 16+\nimport createContext from \"./createContext\";\n\nconst createNamedContext = name => {\n  const context = createContext();\n  context.displayName = name;\n\n  return context;\n};\n\nexport default createNamedContext;\n","import createNamedContext from \"./createNamedContext\";\n\nconst historyContext = /*#__PURE__*/ createNamedContext(\"Router-History\");\nexport default historyContext;\n","import createNamedContext from \"./createNamedContext\";\n\nconst context = /*#__PURE__*/ createNamedContext(\"Router\");\nexport default context;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"tiny-warning\";\n\nimport HistoryContext from \"./HistoryContext.js\";\nimport RouterContext from \"./RouterContext.js\";\n\n/**\n * The public API for putting history on context.\n */\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      location: props.history.location\n    };\n\n    // This is a bit of a hack. We have to start listening for location\n    // changes here in the constructor in case there are any <Redirect>s\n    // on the initial render. If there are, they will replace/push when\n    // they mount and since cDM fires in children before parents, we may\n    // get a new location before the <Router> is mounted.\n    this._isMounted = false;\n    this._pendingLocation = null;\n\n    if (!props.staticContext) {\n      this.unlisten = props.history.listen(location => {\n        this._pendingLocation = location;\n      });\n    }\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n\n    if (this.unlisten) {\n      // Any pre-mount location changes have been captured at\n      // this point, so unregister the listener.\n      this.unlisten();\n    }\n    if (!this.props.staticContext) {\n      this.unlisten = this.props.history.listen(location => {\n        if (this._isMounted) {\n          this.setState({ location });\n        }\n      });\n    }\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.unlisten) {\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  }\n\n  render() {\n    return (\n      <RouterContext.Provider\n        value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      >\n        <HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        />\n      </RouterContext.Provider>\n    );\n  }\n}\n\nif (__DEV__) {\n  Router.propTypes = {\n    children: PropTypes.node,\n    history: PropTypes.object.isRequired,\n    staticContext: PropTypes.object\n  };\n\n  Router.prototype.componentDidUpdate = function(prevProps) {\n    warning(\n      prevProps.history === this.props.history,\n      \"You cannot change <Router history>\"\n    );\n  };\n}\n\nexport default Router;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createMemoryHistory as createHistory } from \"history\";\nimport warning from \"tiny-warning\";\n\nimport Router from \"./Router.js\";\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\nclass MemoryRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return <Router history={this.history} children={this.props.children} />;\n  }\n}\n\nif (__DEV__) {\n  MemoryRouter.propTypes = {\n    initialEntries: PropTypes.array,\n    initialIndex: PropTypes.number,\n    getUserConfirmation: PropTypes.func,\n    keyLength: PropTypes.number,\n    children: PropTypes.node\n  };\n\n  MemoryRouter.prototype.componentDidMount = function() {\n    warning(\n      !this.props.history,\n      \"<MemoryRouter> ignores the history prop. To use a custom history, \" +\n        \"use `import { Router }` instead of `import { MemoryRouter as Router }`.\"\n    );\n  };\n}\n\nexport default MemoryRouter;\n","import React from \"react\";\n\nclass Lifecycle extends React.Component {\n  componentDidMount() {\n    if (this.props.onMount) this.props.onMount.call(this, this);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\n  }\n\n  componentWillUnmount() {\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\n  }\n\n  render() {\n    return null;\n  }\n}\n\nexport default Lifecycle;\n","import pathToRegexp from \"path-to-regexp\";\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nfunction compilePath(path, options) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) return pathCache[path];\n\n  const keys = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = { regexp, keys };\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\n\n/**\n * Public API for matching a URL pathname to a path.\n */\nfunction matchPath(pathname, options = {}) {\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = { path: options };\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  const paths = [].concat(path);\n\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    if (matched) return matched;\n\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexport default matchPath;\n","import React from \"react\";\nimport { isValidElementType } from \"react-is\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport matchPath from \"./matchPath.js\";\n\nfunction isEmptyChildren(children) {\n  return React.Children.count(children) === 0;\n}\n\nfunction evalChildrenDev(children, props, path) {\n  const value = children(props);\n\n  warning(\n    value !== undefined,\n    \"You returned `undefined` from the `children` function of \" +\n      `<Route${path ? ` path=\"${path}\"` : \"\"}>, but you ` +\n      \"should have returned a React element or `null`\"\n  );\n\n  return value || null;\n}\n\n/**\n * The public API for matching a single path and rendering.\n */\nclass Route extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Route> outside a <Router>\");\n\n          const location = this.props.location || context.location;\n          const match = this.props.computedMatch\n            ? this.props.computedMatch // <Switch> already computed the match for us\n            : this.props.path\n            ? matchPath(location.pathname, this.props)\n            : context.match;\n\n          const props = { ...context, location, match };\n\n          let { children, component, render } = this.props;\n\n          // Preact uses an empty array as children by\n          // default, so use null if that's the case.\n          if (Array.isArray(children) && isEmptyChildren(children)) {\n            children = null;\n          }\n\n          return (\n            <RouterContext.Provider value={props}>\n              {props.match\n                ? children\n                  ? typeof children === \"function\"\n                    ? __DEV__\n                      ? evalChildrenDev(children, props, this.props.path)\n                      : children(props)\n                    : children\n                  : component\n                  ? React.createElement(component, props)\n                  : render\n                  ? render(props)\n                  : null\n                : typeof children === \"function\"\n                ? __DEV__\n                  ? evalChildrenDev(children, props, this.props.path)\n                  : children(props)\n                : null}\n            </RouterContext.Provider>\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\nif (__DEV__) {\n  Route.propTypes = {\n    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n    component: (props, propName) => {\n      if (props[propName] && !isValidElementType(props[propName])) {\n        return new Error(\n          `Invalid prop 'component' supplied to 'Route': the prop is not a valid React component`\n        );\n      }\n    },\n    exact: PropTypes.bool,\n    location: PropTypes.object,\n    path: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.string)\n    ]),\n    render: PropTypes.func,\n    sensitive: PropTypes.bool,\n    strict: PropTypes.bool\n  };\n\n  Route.prototype.componentDidMount = function() {\n    warning(\n      !(\n        this.props.children &&\n        !isEmptyChildren(this.props.children) &&\n        this.props.component\n      ),\n      \"You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored\"\n    );\n\n    warning(\n      !(\n        this.props.children &&\n        !isEmptyChildren(this.props.children) &&\n        this.props.render\n      ),\n      \"You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored\"\n    );\n\n    warning(\n      !(this.props.component && this.props.render),\n      \"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored\"\n    );\n  };\n\n  Route.prototype.componentDidUpdate = function(prevProps) {\n    warning(\n      !(this.props.location && !prevProps.location),\n      '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\n    );\n\n    warning(\n      !(!this.props.location && prevProps.location),\n      '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\n    );\n  };\n}\n\nexport default Route;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createLocation, createPath } from \"history\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport Router from \"./Router.js\";\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === \"/\" ? path : \"/\" + path;\n}\n\nfunction addBasename(basename, location) {\n  if (!basename) return location;\n\n  return {\n    ...location,\n    pathname: addLeadingSlash(basename) + location.pathname\n  };\n}\n\nfunction stripBasename(basename, location) {\n  if (!basename) return location;\n\n  const base = addLeadingSlash(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return {\n    ...location,\n    pathname: location.pathname.substr(base.length)\n  };\n}\n\nfunction createURL(location) {\n  return typeof location === \"string\" ? location : createPath(location);\n}\n\nfunction staticHandler(methodName) {\n  return () => {\n    invariant(false, \"You cannot %s with <StaticRouter>\", methodName);\n  };\n}\n\nfunction noop() {}\n\n/**\n * The public top-level API for a \"static\" <Router>, so-called because it\n * can't actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\nclass StaticRouter extends React.Component {\n  navigateTo(location, action) {\n    const { basename = \"\", context = {} } = this.props;\n    context.action = action;\n    context.location = addBasename(basename, createLocation(location));\n    context.url = createURL(context.location);\n  }\n\n  handlePush = location => this.navigateTo(location, \"PUSH\");\n  handleReplace = location => this.navigateTo(location, \"REPLACE\");\n  handleListen = () => noop;\n  handleBlock = () => noop;\n\n  render() {\n    const { basename = \"\", context = {}, location = \"/\", ...rest } = this.props;\n\n    const history = {\n      createHref: path => addLeadingSlash(basename + createURL(path)),\n      action: \"POP\",\n      location: stripBasename(basename, createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler(\"go\"),\n      goBack: staticHandler(\"goBack\"),\n      goForward: staticHandler(\"goForward\"),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n\n    return <Router {...rest} history={history} staticContext={context} />;\n  }\n}\n\nif (__DEV__) {\n  StaticRouter.propTypes = {\n    basename: PropTypes.string,\n    context: PropTypes.object,\n    location: PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n  };\n\n  StaticRouter.prototype.componentDidMount = function() {\n    warning(\n      !this.props.history,\n      \"<StaticRouter> ignores the history prop. To use a custom history, \" +\n        \"use `import { Router }` instead of `import { StaticRouter as Router }`.\"\n    );\n  };\n}\n\nexport default StaticRouter;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport matchPath from \"./matchPath.js\";\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\nclass Switch extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          invariant(context, \"You should not use <Switch> outside a <Router>\");\n\n          const location = this.props.location || context.location;\n\n          let element, match;\n\n          // We use React.Children.forEach instead of React.Children.toArray().find()\n          // here because toArray adds keys to all child elements and we do not want\n          // to trigger an unmount/remount for two <Route>s that render the same\n          // component at different URLs.\n          React.Children.forEach(this.props.children, child => {\n            if (match == null && React.isValidElement(child)) {\n              element = child;\n\n              const path = child.props.path || child.props.from;\n\n              match = path\n                ? matchPath(location.pathname, { ...child.props, path })\n                : context.match;\n            }\n          });\n\n          return match\n            ? React.cloneElement(element, { location, computedMatch: match })\n            : null;\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\nif (__DEV__) {\n  Switch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object\n  };\n\n  Switch.prototype.componentDidUpdate = function(prevProps) {\n    warning(\n      !(this.props.location && !prevProps.location),\n      '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\n    );\n\n    warning(\n      !(!this.props.location && prevProps.location),\n      '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\n    );\n  };\n}\n\nexport default Switch;\n","import React from \"react\";\nimport invariant from \"tiny-invariant\";\n\nimport RouterContext from \"./RouterContext.js\";\nimport HistoryContext from \"./HistoryContext.js\";\nimport matchPath from \"./matchPath.js\";\n\nconst useContext = React.useContext;\n\nexport function useHistory() {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useHistory()\"\n    );\n  }\n\n  return useContext(HistoryContext);\n}\n\nexport function useLocation() {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useLocation()\"\n    );\n  }\n\n  return useContext(RouterContext).location;\n}\n\nexport function useParams() {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useParams()\"\n    );\n  }\n\n  const match = useContext(RouterContext).match;\n  return match ? match.params : {};\n}\n\nexport function useRouteMatch(path) {\n  if (__DEV__) {\n    invariant(\n      typeof useContext === \"function\",\n      \"You must use React >= 16.8 in order to use useRouteMatch()\"\n    );\n  }\n\n  const location = useLocation();\n  const match = useContext(RouterContext).match;\n  return path ? matchPath(location.pathname, path) : match;\n}\n"],"names":["MAX_SIGNED_31_BIT_INT","commonjsGlobal","globalThis","window","global","createContext","React","defaultValue","calculateChangedBits","key","contextProp","Provider","_React$Component","value","handlers","emitter","_this","props","on","handler","push","off","filter","h","get","set","newValue","changedBits","forEach","getChildContext","this","_ref","componentWillReceiveProps","nextProps","oldValue","x","y","render","children","childContextTypes","_Provider$childContex","PropTypes","isRequired","Consumer","_React$Component2","observedBits","state","_this2","getValue","onUpdate","setState","componentDidMount","context","componentWillUnmount","Array","isArray","contextTypes","_Consumer$contextType","createNamedContext","name","displayName","historyContext","Router","location","history","_isMounted","_pendingLocation","staticContext","unlisten","listen","computeRootMatch","pathname","path","url","params","isExact","match","cache$1","cacheLimit$1","cacheCount$1","matchPath","options","_options","exact","_options$exact","strict","_options$strict","sensitive","_options$sensitive","concat","reduce","matched","cacheKey","end","pathCache","keys","result","regexp","pathToRegexp","compilePath$1","_compilePath","exec","values","slice","memo","index","Route","context$1","invariant","computedMatch","_extends","_this$props","component","count","isEmptyChildren","Switch","element","child","from","useContext","useHistory","useLocation"],"sourceRoot":""}